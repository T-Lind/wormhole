#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, rgba32f) uniform writeonly image2D destTex;

// UBO for camera data
layout(std140, binding = 0) uniform Camera {
    vec3 position;
    float pad1;
    vec3 target;
    float pad2;
    vec3 up;
    float pad3;
    float fov;
} u_camera;

// ============================================================================
// STRUCTS
// ============================================================================
struct Sphere {
    vec4 centerAndRadius; // .xyz: center, .w: radius
    vec4 color;           // .xyz: color
    vec4 properties;      // .x: isEmissive (1.0 or 0.0), .y: universeID
};

struct Star {
    vec4 data; // .xyz = direction, .w = brightness
    vec4 colorAndSize; // .xyz = color, .w = size
};

struct Triangle {
    vec3 v0, v1, v2;
    vec3 color;
    int isEmissive;
};

layout(std430, binding = 1) buffer SphereBuffer {
    Sphere spheres[];
};

layout(std430, binding = 3) buffer StarBuffer {
    Star stars[];
};

layout(std430, binding = 4) buffer TriangleBuffer {
    Triangle triangles[];
};

uniform int currentUniverse;
uniform int numSpheres;
uniform int numStars;
uniform int numTriangles;
uniform vec3 sunPosU1;
uniform vec3 sunPosU2;
uniform vec3 sunColorU1;
uniform vec3 sunColorU2;
uniform float time;

const float THROAT_RADIUS = 15.0f;
const vec3 THROAT_CENTER = vec3(0, 0, 0);

// Procedural noise for sun surface
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

float noise(vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
}

float fbm(vec2 st) {
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 0.0;
    for (int i = 0; i < 6; i++) {
        value += amplitude * noise(st);
        st *= 2.0;
        amplitude *= 0.5;
    }
    return value;
}

struct HitInfo {
    bool hit;
    float distance;
    vec3 normal;
    vec3 color;
    int isEmissive;
    vec3 center;
    float radius;
};

// ============================================================================
// INTERSECTION TESTS
// ============================================================================
HitInfo intersectSphere(vec3 rayOrigin, vec3 rayDir, vec4 centerAndRadius, vec4 color, vec4 properties) {
    HitInfo hit;
    hit.hit = false; // <-- CRITICAL FIX: Initialize hit to false
    vec3 oc = rayOrigin - centerAndRadius.xyz;
    float a = dot(rayDir, rayDir);
    float b = 2.0 * dot(oc, rayDir);
    float c = dot(oc, oc) - centerAndRadius.w * centerAndRadius.w;
    float discriminant = b * b - 4 * a * c;

    if (discriminant >= 0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if (t > 0.001) {
            hit.hit = true;
            hit.distance = t;
            hit.normal = normalize((rayOrigin + rayDir * t) - centerAndRadius.xyz);
            hit.color = color.rgb;
            hit.isEmissive = int(properties.x);
            // Add these to make the struct complete for return
            hit.center = centerAndRadius.xyz;
            hit.radius = centerAndRadius.w;
        }
    }
    return hit;
}

// Ray-AABB (Cube) intersection - REMOVED as it's no longer used

// Möller–Trumbore ray-triangle intersection algorithm
bool intersectTriangle(vec3 rayOrigin, vec3 rayDir, Triangle tri, inout float t) {
    vec3 edge1 = tri.v1 - tri.v0;
    vec3 edge2 = tri.v2 - tri.v0;
    vec3 h = cross(rayDir, edge2);
    float a = dot(edge1, h);

    if (a > -1e-6 && a < 1e-6) // Ray is parallel to the triangle
        return false;

    float f = 1.0 / a;
    vec3 s = rayOrigin - tri.v0;
    float u = f * dot(s, h);

    if (u < 0.0 || u > 1.0)
        return false;

    vec3 q = cross(s, edge1);
    float v = f * dot(rayDir, q);

    if (v < 0.0 || u + v > 1.0)
        return false;

    // At this stage we can compute t to find out where the intersection point is on the line.
    float current_t = f * dot(edge2, q);

    if (current_t > 1e-6) { // Ray intersection
        t = current_t;
        return true;
    } else { // This means that there is a line intersection but not a ray intersection.
        return false;
    }
}

HitInfo traceScene(vec3 origin, vec3 direction, int universe) {
    HitInfo closestHit;
    closestHit.hit = false; // <-- CRITICAL FIX: Initialize hit to false
    closestHit.distance = 1e10;

    for (int i = 0; i < numSpheres; ++i) {
        Sphere sphere = spheres[i];
        if (int(sphere.properties.y) == universe) {
            HitInfo currentHit = intersectSphere(origin, direction, sphere.centerAndRadius, sphere.color, sphere.properties);
            if (currentHit.hit && currentHit.distance < closestHit.distance) {
                closestHit = currentHit;
            }
        }
    }
    
    // Check for OBJ triangles - we'll assume they are in universe 1 for now
    if (universe == 1) {
        for (int i = 0; i < numTriangles; ++i) {
            float t;
            if (intersectTriangle(origin, direction, triangles[i], t) && t < closestHit.distance) {
                closestHit.hit = true;
                closestHit.distance = t;
                vec3 edge1 = triangles[i].v1 - triangles[i].v0;
                vec3 edge2 = triangles[i].v2 - triangles[i].v0;
                closestHit.normal = normalize(cross(edge1, edge2));
                closestHit.color = triangles[i].color;
                closestHit.isEmissive = triangles[i].isEmissive;
            }
        }
    }

    return closestHit;
}

// ============================================================================
// BACKGROUNDS
// ============================================================================
vec3 getStarfieldColor(vec3 direction) {
    vec3 color = vec3(0.0);

    for(int i = 0; i < numStars; ++i) {
        vec3 star_dir = stars[i].data.xyz;
        float dist = acos(dot(direction, star_dir));
        
        float intensity = stars[i].data.w * smoothstep(stars[i].colorAndSize.w, 0.0, dist);
        
        if (intensity > 0.0) {
            color += stars[i].colorAndSize.xyz * intensity;
        }
    }
    return color;
}

// ============================================================================
// MAIN RAYTRACING LOGIC
// ============================================================================
void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(destTex);
    if (pixel_coords.x >= dims.x || pixel_coords.y >= dims.y) {
        return;
    }

    // Camera setup
    vec3 forward = normalize(u_camera.target - u_camera.position);
    vec3 right = normalize(cross(forward, u_camera.up));
    vec3 up = cross(right, forward);
    float aspect = float(dims.x) / float(dims.y);
    float tanHalfFov = tan(radians(u_camera.fov) * 0.5);

    // Get ray direction
    float u = (2.0 * (pixel_coords.x + 0.5) / dims.x - 1.0) * aspect * tanHalfFov;
    float v = (1.0 - 2.0 * (pixel_coords.y + 0.5) / dims.y) * tanHalfFov;
    vec3 rayDir = normalize(u * right + v * up + forward);

    // Simplified Wormhole intersection (just a sphere test)
    float t_throat;
    vec3 throat_normal; // unused
    Sphere throat_sphere = Sphere(vec4(THROAT_CENTER, THROAT_RADIUS), vec4(0), vec4(0, 0, 0, 0)); // universeID is 0 for throat
    HitInfo hitsThroat = intersectSphere(u_camera.position, rayDir, throat_sphere.centerAndRadius, throat_sphere.color, throat_sphere.properties);

    HitInfo sceneHit = traceScene(u_camera.position, rayDir, currentUniverse);

    vec3 final_color;

    // Case 1: Hit local object
    if (sceneHit.hit && (!hitsThroat.hit || sceneHit.distance < hitsThroat.distance)) {
        // If the hit object is emissive, render a procedural sun
        if (sceneHit.isEmissive == 1) {
            vec3 hitPoint = u_camera.position + rayDir * sceneHit.distance;
            
            // Get surface coordinates for procedural texture
            vec3 localPos = hitPoint - sceneHit.center;
            vec2 uv = vec2(atan(localPos.z, localPos.x) / (2.0 * 3.14159), acos(localPos.y / sceneHit.radius) / 3.14159);
            
            // Procedural sun surface
            float sun_noise = fbm(uv * 10.0 + vec2(0.1,0.1) /* adding a small offset to avoid artifacts */ );
            vec3 sun_color = sceneHit.color * (0.8 + sun_noise * 0.4);
            
            final_color = sun_color;

        } else {
            vec3 hitPoint = u_camera.position + rayDir * sceneHit.distance;
            vec3 viewDir = -rayDir;
            
            // LIGHTING: Light direction is now from the sun in the current universe
            vec3 sunPos = (currentUniverse == 1) ? sunPosU1 : sunPosU2;
            vec3 lightDir = normalize(sunPos - hitPoint);
            
            float diffuse = max(0.0, dot(sceneHit.normal, lightDir));
            vec3 reflectDir = reflect(-lightDir, sceneHit.normal);
            float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);

            float ambient = 0.3;
            vec3 sunColor = (currentUniverse == 1) ? sunColorU1 : sunColorU2;
            final_color = sceneHit.color * (ambient + diffuse * 0.7) + sunColor * spec;
        }
    }
    // Case 2: Hit wormhole
    else if (hitsThroat.hit) {
        vec3 P_in = u_camera.position + rayDir * hitsThroat.distance;
        vec3 hit_normal = normalize(P_in - THROAT_CENTER);
        
        float fresnel = pow(1.0 - abs(dot(rayDir, hit_normal)), 3.0);
        
        vec3 refracted_dir = refract(rayDir, hit_normal, 1.0 / 1.5);
        vec3 new_origin = P_in - hit_normal * (THROAT_RADIUS * 2.0f) + refracted_dir * 0.1;
        
        int otherUniverse = (currentUniverse == 1) ? 2 : 1;
        HitInfo otherSceneHit = traceScene(new_origin, refracted_dir, otherUniverse);

        vec3 remote_color;
        if (otherSceneHit.hit) {
            // If hit object is emissive (a sun)
            if (otherSceneHit.isEmissive == 1) {
                 vec3 hitPoint = new_origin + refracted_dir * otherSceneHit.distance;
                 vec3 localPos = hitPoint - otherSceneHit.center;
                 vec2 uv = vec2(atan(localPos.z, localPos.x) / (2.0 * 3.14159), acos(localPos.y / otherSceneHit.radius) / 3.14159);
                 // Procedural sun surface (for remote sun)
                 float sun_noise = fbm(uv * 10.0 + vec2(0.1,0.1));
                 vec3 sun_color = otherSceneHit.color * (0.8 + sun_noise * 0.4);
                 
                 remote_color = sun_color;
            } else {
                vec3 hitPoint = new_origin + refracted_dir * otherSceneHit.distance;
                vec3 viewDir = -refracted_dir;
                
                // LIGHTING: Light direction is now from the sun in the OTHER universe
                vec3 sunPos = (otherUniverse == 1) ? sunPosU1 : sunPosU2;
                vec3 lightDir = normalize(sunPos - hitPoint);
                
                float diffuse = max(0.0, dot(otherSceneHit.normal, lightDir));
                vec3 reflectDir = reflect(-lightDir, otherSceneHit.normal);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                vec3 sunColor = (otherUniverse == 1) ? sunColorU1 : sunColorU2;
                remote_color = otherSceneHit.color * (0.3 + diffuse * 0.7) + sunColor * spec;
            }
        } else {
            remote_color = getStarfieldColor(refracted_dir);
        }
        
        final_color = mix(remote_color, vec3(0.5, 0.8, 1.0), fresnel * 0.8);
    }
    // Case 3: Hit background
    else {
        final_color = getStarfieldColor(rayDir);
    }

    imageStore(destTex, pixel_coords, vec4(final_color, 1.0));
}
